#!/bin/sh
# -*- mode: sh; -*- vim: ft=sh:ts=2:sw=2:norl:et:
# Time-stamp: <2025-07-28 06:11:37 cf>
# Box: cf [Linux 6.15.6-zen1-1-zen x86_64 GNU/Linux]

PS1=" âŸ© "

[ -f "$XDG_CONFIG_HOME/shell/aliasrc" ] && . "$XDG_CONFIG_HOME/shell/aliasrc"

alias c='clear'
alias q='exit'
alias h='help'

mkd() { for d in "$@"; do  mkdir -pv "$d" ; done ; }
mkcd() { d="$1"; mkdir -pv "$d" && cd "$d" || return 1 ; return 0 ; }
cds() {
    t="$1"
    {
        [ -f "$t" ] && cd "$(dirname "$t")"
        [ -d "$t" ] && cd "$t"
        return 0
    } || { printf '%s does not exist; create it now? [y/N] ' "$t"
           stty -echo -icanon
           dd bs=1 count=1 2>/dev/null | grep -qiE "y" && mkdir -pv "$t" && cd "$t"
           stty sane
    } || return 1
    return 0
}

try_exec() {
    echo "Trying shell $1"
    type "$1" > /dev/null 2>&1 && exec "$@"
}

log() {
    ts=$(date +"%F_%H%M-%S")
    logdir="$HOME/.local/var/log"
    logfile=${LOGFILE:-"$logdir/$1_$ts.log"}
    echo "$@" >> $logfile
}

log_file() {
    log BEGIN "$1"
    log_file_i=1
    while IFS= read -r log_file_line; do
        printf '%5d\t%s\n' "$log_file_i" "$log_file_line"
        log_file_i=$(($log_file_i+1))
    done < "$1" >> "$logfile"
    log END "$1"
}

warn() {
    log "WARNING: $*"
    WARNINGS="${WARNINGS}WARNING: $*\n"
}

toupper() {
    echo "$@" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
}

tolower() {
    echo "$@" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
}

c_escape() {
    echo "$*" | sed 's/["\\]/\\\0/g'
}

sh_quote() {
    v=$(echo "$1" | sed "s/'/'\\\\''/g")
    test "x$v" = "x${v#*[!A-Za-z0-9_/.+-]}" || v="'$v'"
    echo "$v"
}

cleanws() {
    echo "$@" | sed 's/^ *//;s/[[:space:]][[:space:]]*/ /g;s/ *$//'
}

filter() {
    pat=$1
    shift
    for v; do
        eval "case '$v' in $pat) printf '%s ' '$v' ;; esac"
    done
}

filter_out() {
    pat=$1
    shift
    for v; do
        eval "case '$v' in $pat) ;; *) printf '%s ' '$v' ;; esac"
    done
}

map() {
    m=$1
    shift
    for v; do eval $m; done
}

add_suffix() {
    suffix=$1
    shift
    for v; do echo ${v}${suffix}; done
}

remove_suffix() {
    suffix=$1
    shift
    for v; do echo ${v%$suffix}; done
}

set_all() {
    value=$1
    shift
    for var in $*; do
        eval $var=$value
    done
}

set_weak() {
    value=$1
    shift
    for var; do
        eval : \${$var:=$value}
    done
}

sanitize_var_name() {
    echo $@ | sed 's/[^A-Za-z0-9_]/_/g'
}

set_sanitized() {
    var=$1
    shift
    eval $(sanitize_var_name "$var")='$*'
}

get_sanitized() {
    eval echo \$$(sanitize_var_name "$1")
}

pushvar() {
    for pvar in $*; do
        eval level=\${${pvar}_level:=0}
        eval ${pvar}_${level}="\$$pvar"
        eval ${pvar}_level=$(($level+1))
    done
}

popvar() {
    for pvar in $*; do
        eval level=\${${pvar}_level:-0}
        test $level = 0 && continue
        eval level=$(($level-1))
        eval $pvar="\${${pvar}_${level}}"
        eval ${pvar}_level=$level
        eval unset ${pvar}_${level}
    done
}

request() {
    for var in $*; do
        eval ${var}_requested=yes
        eval $var=
    done
}

warn_if_gets_disabled() {
    for var in $*; do
        WARN_IF_GETS_DISABLED_LIST="$WARN_IF_GETS_DISABLED_LIST $var"
    done
}

enable() {
    set_all yes $*
}

disable() {
    set_all no $*
}

disable_with_reason() {
    disable $1
    eval "${1}_disable_reason=\"$2\""
    if requested $1; then
        die "ERROR: $1 requested, but $2"
    fi
}

enable_weak() {
    set_weak yes $*
}

disable_weak() {
    set_weak no $*
}

enable_sanitized() {
    for var; do
        enable $(sanitize_var_name $var)
    done
}

disable_sanitized() {
    for var; do
        disable $(sanitize_var_name $var)
    done
}

do_enable_deep() {
    for var; do
        enabled $var && continue
        set -- $var
        eval enable_deep \$${var}_select
        var=$1
        eval enable_deep_weak \$${var}_suggest
    done
}

enable_deep() {
    do_enable_deep $*
    enable $*
}

enable_deep_weak() {
    for var; do
        disabled $var && continue
        set -- $var
        do_enable_deep $var
        var=$1
        enable_weak $var
    done
}

requested() {
    test "${1#!}" = "$1" && op="=" || op="!="
    eval test "x\$${1#!}_requested" $op "xyes"
}

enabled() {
    test "${1#!}" = "$1" && op="=" || op="!="
    eval test "x\$${1#!}" $op "xyes"
}

disabled() {
    test "${1#!}" = "$1" && op="=" || op="!="
    eval test "x\$${1#!}" $op "xno"
}

enabled_all() {
    for opt; do
        enabled $opt || return 1
    done
}

disabled_all() {
    for opt; do
        disabled $opt || return 1
    done
}

enabled_any() {
    for opt; do
        enabled $opt && return 0
    done
}

disabled_any() {
    for opt; do
        disabled $opt && return 0
    done
    return 1
}

set_default() {
    for opt; do
        eval : \${$opt:=\$${opt}_default}
    done
}

is_in() {
    value=$1
    shift
    for var in $*; do
        [ $var = $value ] && return 0
    done
    return 1
}

print_enabled() {
    suf=$1
    shift
    for v; do
        enabled $v && printf "%s\n" ${v%$suf}
    done
}

append() {
    var=$1
    shift
    eval "$var=\"\$$var $*\""
}

prepend() {
    var=$1
    shift
    eval "$var=\"$* \$$var\""
}

reverse () {
    eval '
        reverse_out=
        for v in $'$1'; do
            reverse_out="$v $reverse_out"
        done
        '$1'=$reverse_out
    '
}

# keeps the last occurence of each non-unique item
unique() {
    unique_out=
    eval unique_in=\$$1
    reverse unique_in
    for v in $unique_in; do
        # " $unique_out" +space such that every item is surrounded with spaces
        case " $unique_out" in *" $v "*) continue; esac  # already in list
        unique_out="$unique_out$v "
    done
    reverse unique_out
    eval $1=\$unique_out
}

resolve() {
    resolve_out=
    eval resolve_in=\$$1
    for v in $resolve_in; do
        eval 'resolve_out="$resolve_out$'$v' "'
    done
    eval $1=\$resolve_out
}

mpyt () {
    [ $# -gt 0 ] || return 1
    id=$(yt-dlp "ytsearch:$*" --skip-download --ignore-errors --quiet --get-id --no-warnings 2>/dev/null)
    [ -n "$id" ] && mpv "https://youtube.com/watch?v=${id}" || return 1
    return 0
}

alias ff='fastfetch'

alias vv='cd ~/Videos'
alias pp='cd ~/Pictures'
alias D='cd ~/Downloads'
alias rr='cd ~/.local/src'
alias sc='cd ~/.local/bin'
