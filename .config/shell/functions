#!/bin/sh
# -*- mode: sh; -*- vim: ft=sh:ts=2:sw=2:norl:et:
# Time-stamp: <2025-07-28 12:15:22 cf>
#       _          _ _  __
#   ___| |__   ___| | |/ _|_ __
#  / __| '_ \ / _ \ | | |_| '_  \
#  \__ \ | | |  __/ | |  _| | | |
#  |___/_| |_|\___|_|_|_| |_| |_|
#
#                        ~shellfn

mkd() { for d in "$@"; do  mkdir -pv "$d" ; done ; }
mkcd() { d="$1"; mkdir -pv "$d" && cd "$d" || return 1 ; return 0 ; }
cd() {
    t="$1"
    {
        [ -f "$t" ] && builtin cd "$(dirname "$t")"
        [ -d "$t" ] && builtin cd "$t"
        return 0
    } || { printf '%s does not exist; create it now? [y/N] ' "$t"
           stty -echo -icanon
           dd bs=1 count=1 2>/dev/null | grep -qiE "y" && mkdir -pv "$t" && builtin cd "$t"
           stty sane
    } || return 1
    return 0
}

try_exec() {
    echo "Trying shell $1"
    type "$1" > /dev/null 2>&1 && exec "$@"
}

log() {
    ts=$(date +"%F_%H%M-%S")
    logdir="$HOME/.local/var/log"
    logfile=${LOGFILE:-"$logdir/$1_$ts.log"}
    echo "$@" >> $logfile
}

log_file() {
    log BEGIN "$1"
    log_file_i=1
    while IFS= read -r log_file_line; do
        printf '%5d\t%s\n' "$log_file_i" "$log_file_line"
        log_file_i=$(($log_file_i+1))
    done < "$1" >> "$logfile"
    log END "$1"
}

warn() {
    log "WARNING: $*"
    WARNINGS="${WARNINGS}WARNING: $*\n"
}

die() {
    log "$@"
    echo "$error_color$bold_color$@$reset_color"
    cat <<EOF

If you think configure made a mistake, make sure you are using the latest
version from Git.  If the latest version fails, report the problem to the
ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.libera.chat.
EOF
    if disabled logging; then
        cat <<EOF
Rerun configure with logging enabled (do not use --disable-logging), and
include the log this produces with your report.
EOF
    else
        cat <<EOF
Include the log file "$logfile" produced by configure as this will help
solve the problem.
EOF
    fi
    exit 1
}

toupper() {
    echo "$@" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
}

tolower() {
    echo "$@" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
}

c_escape() {
    echo "$*" | sed 's/["\\]/\\\0/g'
}

sh_quote() {
    v=$(echo "$1" | sed "s/'/'\\\\''/g")
    test "x$v" = "x${v#*[!A-Za-z0-9_/.+-]}" || v="'$v'"
    echo "$v"
}

cleanws() {
    echo "$@" | sed 's/^ *//;s/[[:space:]][[:space:]]*/ /g;s/ *$//'
}

filter() {
    pat=$1
    shift
    for v; do
        eval "case '$v' in $pat) printf '%s ' '$v' ;; esac"
    done
}

filter_out() {
    pat=$1
    shift
    for v; do
        eval "case '$v' in $pat) ;; *) printf '%s ' '$v' ;; esac"
    done
}

map() {
    m=$1
    shift
    for v; do eval $m; done
}

add_suffix() {
    suffix=$1
    shift
    for v; do echo ${v}${suffix}; done
}

remove_suffix() {
    suffix=$1
    shift
    for v; do echo ${v%$suffix}; done
}

set_all() {
    value=$1
    shift
    for var in $*; do
        eval $var=$value
    done
}

set_weak() {
    value=$1
    shift
    for var; do
        eval : \${$var:=$value}
    done
}

sanitize_var_name() {
    echo $@ | sed 's/[^A-Za-z0-9_]/_/g'
}

set_sanitized() {
    var=$1
    shift
    eval $(sanitize_var_name "$var")='$*'
}

get_sanitized() {
    eval echo \$$(sanitize_var_name "$1")
}

pushvar() {
    for pvar in $*; do
        eval level=\${${pvar}_level:=0}
        eval ${pvar}_${level}="\$$pvar"
        eval ${pvar}_level=$(($level+1))
    done
}

popvar() {
    for pvar in $*; do
        eval level=\${${pvar}_level:-0}
        test $level = 0 && continue
        eval level=$(($level-1))
        eval $pvar="\${${pvar}_${level}}"
        eval ${pvar}_level=$level
        eval unset ${pvar}_${level}
    done
}

request() {
    for var in $*; do
        eval ${var}_requested=yes
        eval $var=
    done
}

warn_if_gets_disabled() {
    for var in $*; do
        WARN_IF_GETS_DISABLED_LIST="$WARN_IF_GETS_DISABLED_LIST $var"
    done
}

enable() {
    set_all yes $*
}

disable() {
    set_all no $*
}

disable_with_reason() {
    disable $1
    eval "${1}_disable_reason=\"$2\""
    if requested $1; then
        die "ERROR: $1 requested, but $2"
    fi
}

enable_weak() {
    set_weak yes $*
}

disable_weak() {
    set_weak no $*
}

enable_sanitized() {
    for var; do
        enable $(sanitize_var_name $var)
    done
}

disable_sanitized() {
    for var; do
        disable $(sanitize_var_name $var)
    done
}

do_enable_deep() {
    for var; do
        enabled $var && continue
        set -- $var
        eval enable_deep \$${var}_select
        var=$1
        eval enable_deep_weak \$${var}_suggest
    done
}

enable_deep() {
    do_enable_deep $*
    enable $*
}

enable_deep_weak() {
    for var; do
        disabled $var && continue
        set -- $var
        do_enable_deep $var
        var=$1
        enable_weak $var
    done
}

requested() {
    test "${1#!}" = "$1" && op="=" || op="!="
    eval test "x\$${1#!}_requested" $op "xyes"
}

enabled() {
    test "${1#!}" = "$1" && op="=" || op="!="
    eval test "x\$${1#!}" $op "xyes"
}

disabled() {
    test "${1#!}" = "$1" && op="=" || op="!="
    eval test "x\$${1#!}" $op "xno"
}

enabled_all() {
    for opt; do
        enabled $opt || return 1
    done
}

disabled_all() {
    for opt; do
        disabled $opt || return 1
    done
}

enabled_any() {
    for opt; do
        enabled $opt && return 0
    done
}

disabled_any() {
    for opt; do
        disabled $opt && return 0
    done
    return 1
}

set_default() {
    for opt; do
        eval : \${$opt:=\$${opt}_default}
    done
}

is_in() {
    value=$1
    shift
    for var in $*; do
        [ $var = $value ] && return 0
    done
    return 1
}

check_deps() {
    for cfg; do
        eval [ x\$${cfg}_checking = xdone ] && continue
        eval [ x\$${cfg}_checking = xinprogress ] && die "Circular dependency for $cfg."

        eval "
        dep_all=\$${cfg}_deps
        dep_any=\$${cfg}_deps_any
        dep_con=\$${cfg}_conflict
        dep_sel=\$${cfg}_select
        dep_sgs=\$${cfg}_suggest
        dep_ifa=\$${cfg}_if
        dep_ifn=\$${cfg}_if_any
        "

        # most of the time here $cfg has no deps - avoid costly no-op work
        if [ "$dep_all$dep_any$dep_con$dep_sel$dep_sgs$dep_ifa$dep_ifn" ]; then
            eval ${cfg}_checking=inprogress

            set -- $cfg "$dep_all" "$dep_any" "$dep_con" "$dep_sel" "$dep_sgs" "$dep_ifa" "$dep_ifn"
            check_deps $dep_all $dep_any $dep_con $dep_sel $dep_sgs $dep_ifa $dep_ifn
            cfg=$1; dep_all=$2; dep_any=$3; dep_con=$4; dep_sel=$5 dep_sgs=$6; dep_ifa=$7; dep_ifn=$8

            [ -n "$dep_ifa" ] && { enabled_all $dep_ifa && enable_weak $cfg; }
            [ -n "$dep_ifn" ] && { enabled_any $dep_ifn && enable_weak $cfg; }
            enabled_all  $dep_all || { disable_with_reason $cfg "not all dependencies are satisfied: $dep_all"; }
            enabled_any  $dep_any || { disable_with_reason $cfg "not any dependency is satisfied: $dep_any"; }
            disabled_all $dep_con || { disable_with_reason $cfg "some conflicting dependencies are unsatisfied: $dep_con"; }
            disabled_any $dep_sel && { disable_with_reason $cfg "some selected dependency is unsatisfied: $dep_sel"; }

            enabled $cfg && enable_deep_weak $dep_sel $dep_sgs

            for dep in $dep_all $dep_any $dep_sel $dep_sgs; do
                # filter out library deps, these do not belong in extralibs
                is_in $dep $LIBRARY_LIST && continue
                enabled $dep && eval append ${cfg}_extralibs ${dep}_extralibs
            done
        fi

        eval ${cfg}_checking=done
    done
}

print_config() {
    pfx=$1
    files=$2
    shift 2
    map 'eval echo "$v \${$v:-no}"' "$@" |
    awk "BEGIN { split(\"$files\", files) }
        {
            c = \"$pfx\" toupper(\$1);
            v = \$2;
            sub(/yes/, 1, v);
            sub(/no/,  0, v);
            for (f in files) {
                file = files[f];
                if (file ~ /\\.h\$/) {
                    printf(\"#define %s %d\\n\", c, v) >>file;
                } else if (file ~ /\\.asm\$/) {
                    printf(\"%%define %s %d\\n\", c, v) >>file;
                } else if (file ~ /\\.mak\$/) {
                    n = -v ? \"\" : \"!\";
                    printf(\"%s%s=yes\\n\", n, c) >>file;
                } else if (file ~ /\\.texi\$/) {
                    pre = -v ? \"\" : \"@c \";
                    yesno = \$2;
                    c2 = tolower(c);
                    gsub(/_/, \"-\", c2);
                    printf(\"%s@set %s %s\\n\", pre, c2, yesno) >>file;
                }
            }
        }"
}

print_enabled() {
    suf=$1
    shift
    for v; do
        enabled $v && printf "%s\n" ${v%$suf}
    done
}

append() {
    var=$1
    shift
    eval "$var=\"\$$var $*\""
}

prepend() {
    var=$1
    shift
    eval "$var=\"$* \$$var\""
}

reverse () {
    eval '
        reverse_out=
        for v in $'$1'; do
            reverse_out="$v $reverse_out"
        done
        '$1'=$reverse_out
    '
}

# keeps the last occurence of each non-unique item
unique() {
    unique_out=
    eval unique_in=\$$1
    reverse unique_in
    for v in $unique_in; do
        # " $unique_out" +space such that every item is surrounded with spaces
        case " $unique_out" in *" $v "*) continue; esac  # already in list
        unique_out="$unique_out$v "
    done
    reverse unique_out
    eval $1=\$unique_out
}

resolve() {
    resolve_out=
    eval resolve_in=\$$1
    for v in $resolve_in; do
        eval 'resolve_out="$resolve_out$'$v' "'
    done
    eval $1=\$resolve_out
}


bescherelle() {
    VERB_DIR=${BESCHERELLE_DIR:-"$HOME/Documents/Bescherelle"}
    [ -d "$VERB_DIR" ] || {
        printf '%s est introuvable. Peut-Ãªtre essayer: `parallel -j0 --joblog %s %s :::: %s` ?\n' "$VERB_DIR" "$(which conjuge)" "$HOME/Templates/org-bescherelle/bescherelle-bootstrap.log" "$(find "$HOME/Templates/org-bescherelle/" -type "$f" -name "verbes")" >&2
        printf 'parallel -j0 --joblog %s %s :::: %s\n' "$VERB_DIR" "$(which conjuge)" "$HOME/Templates/org-bescherelle/bescherelle-bootstrap.log" "$(find "$HOME/Templates/org-bescherelle/" -type "$f" -name "verbes")" | xclip -in -selection clipboard
        return 1
    }
    cat "$VERB_DIR"/* | grep -vE '^[*#]' | sed "/^$/d" | fzf --multi | sed -e "s/'/â/g;s/oe/Å/gI"
    return 0
}

mpyt () {
    [ $# -gt 0 ] || return 1
    id=$(yt-dlp "ytsearch:$*" --skip-download --ignore-errors --quiet --get-id --no-warnings 2>/dev/null)
    [ -n "$id" ] && mpv "https://youtube.com/watch?v=${id}" || return 1
    return 0
}

xdohide() {
    [ $# -gt 0 ] || return 1
    cmd="$*"
    w="$WINDOWID"
    export w
    xdo hide "$w"
    eval $("$cmd")
    xdo show "$w"
    unset w
    return 0
}

scf() {
    if [ $# -lt 1 ] ; then
        f=$(find "$XDG_CONFIG_HOME/shell" -type f | fzf)
    else
        f=$(find "$@" | fzf)
    fi
    [ -f "$f" ] || return 1
    emc "$f"
    echo "$f" | \
        grep -q "\(functions\|aliases\|profile\|alias\|zshrc\)" && \
        source "$f" && echo "$f sourced."
    return 0
}

findfn() {
    t="$1"
    f=$(type "$t" | awk -F 'is a shell function from ' '{print $2}')
    [ -f "$f" ] && l=$(grep -rn "${t}()" "$f" | cut -d: -f1) || return 1
    emc +"${l}" "${f}" || { echo "failed to open ${f}:${l}" >&2 ; return 1 ; }
    unset t f l
    return 0
}

findalias() {
    a="$1"
    grep -rn "${a}='" "${XDG_CONFIG_HOME:-$HOME/.config}/shell/" | while read -r t ; do
        f=$(echo "$t" | cut -d':' -f1)
        l=$(echo "$t" | cut -d':' -f2)
        ( [ -f "$f" ] && [ -n "$l" ] && emc +"${l}" "${f}" ; ) || return 1
        unset l f a
    done
    return 0
}

whem() {
    t="$1"
    f=$(which "$t")
    ( [ -f "$f" ] && $EDITOR "$f" ; ) || ( findalias "$t" ; ) || ( findfn "$t" ; ) || { echo "could  not open $t" >&2 ; return 1 ; }
    unset t f
    return 0
}

ve() {
    for f in "$@" ; do
        w=$(which "$f");
        t=$(type "$f");
        a=$(alias "$f");
        ([ -f "$w" ] && file "$w" && $VISUAL "$w") || echo "$t" ;
        if [ -n "$a" ] ; then
            grep -rn " ${f}=" "$XDG_CONFIG_HOME/shell" | fzf | while read -r e ; do
                file=$(echo "$e" | awk -F: '{print $1}')
                ln=$(echo "$e" | awk -F: '{print $2}')
                case "$EDITOR" in
                    *vi*) "$EDITOR" "$file" -c :"${ln}" ;;
                    em*) emc "+${ln}" "$file" ;;
                esac
            done
        fi
    done
    return 0
}

greps() {
    for p in "$@" ; do
        pgrep "$p" | xargs ps
    done
}

awkargc() {
    f="$1"
    c="${2:-2}"
    awk -F"$f" '{for(i='"$c"'; i<=NF; i++) printf "%s%s", $i, (i<NF ? '"$c"' : ""); print ""}'
}

trim_last_if_match() { f="$1" ; p="$2" ; tail -n 1 "$f" | grep -qiE "$p" && sed -i '$d' "$f" ; }
trim_if_match() {
  pattern="$1"
  awk -v IGNORECASE=1 -v pat="$pattern" '
    { lines[NR] = $0 }
    END {
      if (lines[NR] ~ pat) NR--
      for (i = 1; i <= NR; i++) print lines[i]
    }
  '
}

# neovim pager width fitting
vman() {
    export MANPAGER="nvim +Man!"
    export MANWIDTH="$(($(tput cols) - 8))"
    command man "$@"
}

# ask stupid questions
gpt() { args=$(printf "%s " "$@") ; tgpt "$args" ; }
ttsgpt() { args=$(printf "%s " "$@") ; tgpt "$args" | tts ; }

# text-to-speech model completion
ttscomp() {
    models=""
    for f in "$HOME/Templates/piper/voices/"*.onnx; do
        case "$f" in
            *.onnx)
                base=$(basename "$f" .onnx)
                if [ -f "$HOME/Templates/piper/voices/$base.onnx.json" ]; then
                    models="$models $base"
                fi
                ;;
        esac
    done
    printf '%s\n' $models
    return 0
}

if echo "$SHELL" | grep -i "zsh" ; then
    compctl -K ttscomp tts 's[-m],[--model]'
    compctl -K ttscomp piper 's[-m],[--model]'
fi

addsv() {
    svdir="/etc/runit/sv"
    sv="$1"
    [ -n "$sv" ] || sv=$(find "$svdir" -maxdepth 1 -type d | fzf --delimiter='/' --with-nth=5)
    echo "$sv" | grep -q "$svdir" && sv=${sv##*/}
    [ -d "$svdir/$sv" ] && {
        sudo ln -sf "${svdir}/${sv}" "/run/runit/service/${sv}"
    } || { echo "Error: $sv doesn't exist in $svdir" >&2 ; return 1 ; }
    sv status "$sv"
    return 0
}

rmsv() {
    local sv="$1"
    local svlink="/run/runit/service/${sv}"
    if [ -z "$sv" ]; then
        echo "Usage: rmsv <service_name>"
        return 1
    fi
    if [ -L "$svlink" ]; then
        sudo rm "$svlink"
        echo "Service ${sv} removed."
        sv status ${sv} 2>/dev/null
    else
        echo "Error: ${svlink} does not exist or is not a symbolic link."
        return 1
    fi
}

# basic media editing helpers
rmsound() {
    input="$1"
    output="no-sound-$1"
    ffmpeg -i "$input" -an -c:v copy "$output"
}

mergeaudio() {
    inputV="$1"
    inputA="$2"
    outputV="$3"
    ffmpeg -i "$inputV" -i "$inputA" -c:v copy -c:a aac -strict experimental "$outputV"
}

trimvid() {
    inputV="$1"
    start="$2"
    to="$3"
    outputV="$4"
    ffmpeg -i "$inputV" -ss "$start" -to "$to" "$outputV"
}

vid2gif() {
    input="$1"
    filename=$(basename -- "$input")
    filename_noext="${filename%.*}"
    output="$filename_noext.gif"
    scale="${2:-200}"
    ffmpeg -i "$input" -vf "scale=-1:$scale" "$output"
}

media_diff() {
  ext="$1"
  reference="${2:-1920x1080}"
  property="${3:-Image}"
  for file in *."${ext}"; do
    value=$(mediainfo --Inform="${property};%" "$file")
    if [ -z "$value" ]; then
      echo "$file: Property '${property}' not found." >&2
      continue
    fi
    if [ "$value" != "$reference" ]; then
      echo "$file: $value"
    fi
  done
}

bak() {
    target="$1"
    backupdir="$HOME/Documents/Backups/5-adhoc"
    backupname="${target}_$(date +%Y-%m-%d_%H%M).tar.gz"
    [ -d "$backupdir" ] || mkdir -p "$backupdir"
    [ -e "$target" ] && tar -zcvf "${backupdir}/${backupname}" "${target}" -P
}

ecf() {
    file="$1"
    [ -n "$file" ] || file=$(printf 'dwmblocks\ndwm\ndmenu\nst\nzshrc\nytfzf\nmpv\nnewsboat\n' | fzf)
    case "$file" in
        dwmblocks)
               file="$HOME/.local/src/dwmblocks/config.h"
               cmd='cd ~/.local/src/dwmblocks && sudo make clean install && { killall -q dwmblocks ; setsid dwmblocks ; } &' ;;
        dwm)
               file="$HOME/.local/src/dwm/config.h"
               cmd='cd ~/.local/src/dwm && sudo make clean install && wmreup' ;;
        dmenu)
               file="$HOME/.local/src/dmenu/config.h"
               cmd='cd ~/.local/src/dmenu && sudo make clean install' ;;
        st)
               file="$HOME/.local/src/st/config.h"
               cmd='cd ~/.local/src/st && sudo make clean install' ;;
        zshrc)
               file="$HOME/.config/zsh/.zshrc"
               cmd='source ~/.config/zsh/.zshrc' ;;
        ytfzf)
               file="$HOME/.config/ytfzf/subscriptions"
               cmd='source ~/.config/ytfzf/subscriptions 2>/dev/null' ;;
        mpv)
               file="$HOME/.config/mpv/input.conf"
               cmd='source ~/.config/mpv/input.conf' ;;
        newsboat)
               file="$HOME/.config/newsboat/urls"
               cmd='source ~/.config/newsboat/urls' ;;
            *) ;;
    esac
    ( $EDITOR "$file" && eval "$cmd" ) || return 1
    return 0
}

sync_subs() {
  subs=(
      '~/.config/ytfzf/subscriptions'
      '~/.config/newsboat/urls'
      '~/.config/pipe-viewer/subscriptions'
      '~/.config/qutebrowser/quickmarks'
  )
  grep -E "^Host " "$HOME/.ssh/config" | grep -Ev "git*" | awk '{print $2}' | while read -r host ; do
      for f in ${subs[@]}; do
          d=$(echo "$f" | awk -F'/' '{print $4"_"$3}')
          rsync --verbose --progress --recursive "$f" "${host}:~/Downloads/${d}_$(date +"%Y-%m-%d")" || continue
      done
  done
}

# monitor directory remaining storage space
freelog() {
    dir="$1"
    storage="cryptlvm"
    if [[ -z $dir ]]; then
        echo "Specify a directory. Usage: freelog <dir>"
        exit 1
    else
        while :; do
            du_output=$(du -h "$dir" | tail -n 1 | awk '{print $1}')
            df_output=$(df -h | grep "$storage" | awk '{print "/ " $3," | "$4, $5}')
            output="$du_output $df_output"
            printf '\r%s' "$output"
            sleep 3
        done
    fi
}

# print available 256 terminal colors
termcolors() {
    for n in {0..255}; do
        printf "%s\033[38;5;${n}mcolour${n}\033[0m \t";
        if [ $(expr $((num+1)) % 8) -eq 0 ]; then
            printf "\n" || continue
        fi
    done
    unset n
    return 0
}

# apend_to() {
#     f="$1"
#     [ -f "$f"] || { echo "can't append to ${f}: not a file. " >&2 ; return 1 ; }
#     shift
#     content=$(cat)
#     ${content}
#     tee -a "$f" ; head "$f" ; tail "$f" ; }

countdown() {
    for i in $(seq $1 -1 1); do
        echo -ne "\r$i";
        sleep 1;
    done
}

curLine() {
    ROW=$(tput lines 2>/dev/null)
    if [ -z "$ROW" ]; then
        ROW=0
    fi
    export LINE="$ROW"
    echo "$ROW"
}

# Install packages using yay (change to pacman/AUR helper of your choice)
yayin() {
    yay -Slq | fzf -q "$1" -m --preview 'yay -Si {1}' --preview-window=right:70% | xargs -ro yay -S
}
# Remove installed packages (change to pacman/AUR helper of your choice)
yayrm() {
    yay -Qq | fzf -q "$1" -m --preview 'yay -Qi {1}' --preview-window=right:70% | xargs -ro yay -Rns
}

# Helper function to integrate yay and fzf
yzf() {
  pos=$1
  shift
  sed "s/ /\t/g" |
    fzf --nth=$pos --multi --history="${FZF_HISTDIR:-$XDG_STATE_HOME/fzf}/history-yzf$pos" \
    --preview-window=60%,border-left \
    --bind="double-click:execute(xdg-open 'https://archlinux.org/packages/{$pos}'),alt-enter:execute(xdg-open 'https://aur.archlinux.org/packages?K={$pos}&SB=p&SO=d&PP=100')" \
    "$@" | cut -f$pos | xargs
}
# Dev note: print -s adds a shell history entry

# List installable packages into fzf and install selection
yas() {
  cache_dir="/tmp/yas-$USER"
  test "$1" = "-y" && rm -rf "$cache_dir" && shift
  mkdir -p "$cache_dir"
  preview_cache="$cache_dir/preview_{2}"
  list_cache="$cache_dir/list"
  { test "$(cat "$list_cache$@" | wc -l)" -lt 50000 && rm "$list_cache$@"; } 2>/dev/null
  pkg=$( (cat "$list_cache$@" 2>/dev/null || { pacman --color=always -Sl "$@"; yay --color=always -Sl aur "$@" } | sed 's/ [^ ]*unknown-version[^ ]*//' | tee "$list_cache$@") | yzf 2 --tiebreak=index --preview="cat $preview_cache 2>/dev/null | grep -v 'Querying' | grep . || yay --color always -Si {2} | tee $preview_cache")
  if test -n "$pkg" ; then
      echo "Installing $pkg..."
      cmd="yay -S ${pkg}"
      print -s "${cmd}"
      eval "$cmd"
      rehash
  fi
}

# List installed packages into fzf and remove selection Tip: use -e to list only explicitly installed packages
yar() {
      pkg=$(yay --color=always -Q "$@" | yzf 1 --tiebreak=length --preview="yay --color always -Qli {1}")
      if test -n "$pkg"
        then echo "Removing $pkg..."
          cmd="yay -R --cascade --recursive $pkg"
          print -s "$cmd"
          eval "$cmd"
      fi
}

# Emojis
emoji() {
    emojis=$(cat ~/Templates/css/emoji.txt)
    selected_emoji=$(echo "$emojis" | fzf)
    echo "$selected_emoji" | cut -d':' -f1 | xclip -selection clipboard
    return
}

mkmpvplaylist() {
    time="${time:-365}"
    folder="${dir:-./}"
    output="${output:-.playlist}"
    play="${play:-0}"
    while :; do
        case "$1" in
            -t|--time) time=$2; shift 2;;
            -d|--dir) dir=$2; shift 2;;
            -o|--output) output=$2; shift 2;;
            -p|--play) play=1; shift;;
            --) shift; break;;
            *) break;;
        esac
    done
    find "$folder" -not -path "$HOME/Videos/edit/*" -not -path "$HOME/Videos/yt/*"  -iname '*.mkv' -o -iname '*.mp4' -o -iname '*.webm' -o -iname '*.avi' -o -iname '*.mov' -o -iname '*.flv' -o -iname '*.wmv' -o -iname '*.mpeg' -o -iname '*.mpg' -o -iname '*.3gp' -type f -mtime -"$time" > "$folder/$output"
    # If play flag is set, play the files
    if [[ $play -eq 1 ]]; then
        find "$folder"  -iname '*.mkv' -o -iname '*.mp4' -o -iname '*.webm' -o -iname '*.avi' -o -iname '*.mov' -o -iname '*.flv' -o -iname '*.wmv' -o -iname '*.mpeg' -o -iname '*.mpg' -o -iname '*.3gp' -type f -mtime -"$time" -print0 | sort -z | xargs -0 mpv --playlist=-
    fi
}

dndmp() {
    mpv --playlist=- < $( dragndrop -p --target --and-exit )
}

# exif_mpv() {
#   fullpath="$(realpath "$1")"
#   title=$(exiftool "$fullpath" -UserComment -j | jq -r '.[].UserComment | fromjson | .Summary.Title')
#   channel="$(basename "$(dirname "$fullpath")")"
#   uri=$(exiftool "$fullpath" -UserComment -j | jq -r '.[].UserComment | fromjson | .Summary.URI')
#   str=$(exiftool -s3 "$fullpath" -UserComment -j | jq -r '.[].UserComment | fromjson | .Summary | "\(.URI) # \(.Title)"')
#   echo "$str"
#   notify-send -i "$fullpath" "$channel" "$title"
#   grep -q "$str" "$MPVQ_PLAYLIST" || echo "$str" >> "$MPVQ_PLAYLIST"
# }

# exif2json() {
#   for f in yt/meta/*/*.jpg; do
#     f=$(realpath "$f")
#     # Extract metadata from EXIF and ensure errors are ignored
#     uri=$(exiftool "$f" -UserComment -j | jq -r '.[].UserComment | fromjson | .Summary.URI // .URI' || true)
#     title=$(exiftool "$f" -UserComment -j | jq -r '.[].UserComment | fromjson | .Summary.Title // .Title' || true)
#     description=$(exiftool "$f" -UserComment -j | jq -r '.[].UserComment | fromjson | .Summary.Description // .Description' || true)
#     uploader=$(exiftool "$f" -UserComment -j | jq -r '.[].UserComment | fromjson | .Metadata.Uploader // .Uploader' || true)
#     id=$(exiftool "$f" -UserComment -j | jq -r '.[].UserComment | fromjson | .Metadata.ID // .ID' || true)
#     # Clean the strings to remove any unwanted characters (like newlines or extra quotes)
#     uri=$(echo "$uri" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     title=$(echo "$title" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     description=$(echo "$description" | sed 's/^"\(.*\)"$/\1/' | sed 's/\r//g')
#     uploader=$(echo "$uploader" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     id=$(echo "$id" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     json=$(jq -n \
#       --arg uploader "$uploader" \
#       --arg uri "$uri" \
#       --arg title "$title" \
#       --arg id "$id" \
#       --arg path "$f" \
#       --arg description "$description" \
#       '{uploader: $uploader, path: $path, uri: $uri, title: $title, id: $id, description: $description}')
#     # Output the cleaned JSON object
#     printf "%s\n" "$json" | jq . -r
#   done
# }

# metadb_rg() {
#   search="$1"
#   while read -r res; do
#     match=$(printf "%s" "$res" | rg --color=always -i "${search}" 2>/dev/null)
#     if [ -n "$match" ]; then
#       uri=$(printf "%s" "$match" | jq -r '.uri')
#       echo "URI: $uri"
#     fi
#   done < <(for f in yt/meta/*/*.jpg; do
#     f=$(realpath "$f")
#     metadata=$(exiftool "$f" -UserComment -j)
#     if [ -z "$metadata" ]; then
#       continue
#     fi
#     uri=$(echo "$metadata" | jq -r '.[].UserComment | fromjson | .Summary.URI // .URI')
#     title=$(echo "$metadata" | jq -r '.[].UserComment | fromjson | .Summary.Title // .Title')
#     description=$(echo "$metadata" | jq -r '.[].UserComment | fromjson | .Summary.Description // .Description')
#     uploader=$(echo "$metadata" | jq -r '.[].UserComment | fromjson | .Summary.Uploader // .Uploader')
#     uri=$(echo "$uri" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     title=$(echo "$title" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     description=$(echo "$description" | sed 's/^"\(.*\)"$/\1/' | tr -d '\n' | sed 's/\r//g')
#     json=$(jq -n \
#       --arg path "$f" \
#       --arg uri "$uri" \
#       --arg title "$title" \
#       --arg description "$description" \
#       '{path: $path, uri: $uri, title: $title, description: $description}')
#     printf "%s\n" "$json"
#   done)
# }

get_yt_desc() {
    yt-dlp -q --no-warnings --skip-download --get-description "$1"
}

jsonfmt() {
  dir=${1:-$(pwd)}
  tmp=$(mktemp -d)
  for f in *.json; do
    jq . "$f" > "$tmp/$f" && mv "$tmp/$f" "$dir" -f
  done && rm -rf "$tmp" && echo "$dir jsons formatted."
}

jsonlink() {
  title=$(jq '.Summary.Title' "$1")
  link="$(jq -r '.Summary."Original URI"' "$1")"
  echo "$link # $title" >> "$MPVQ_PLAYLIST"
}

mpvqsv() {
  mpvqsv="$HOME/.local/bin/statusbar/sb-mpvq"
  down="${mpvqsv}.down"
  if [ -f "$down" ]; then
    echo "mpvqsv is down."
    mv "${down}" "${mpvqsv}" -f > /dev/null
    echo "mpvq up and running"
    return
  else
    mv "${mpvqsv}" "${down}"
    echo "mpvqsv down."
    rm -f /tmp/mpvqicon
    return
  fi
  ls "${mpvqsv}" || echo "mpvqsv down"
  return 0
}

apndYtJsons() {
  playlist="${1:-$MPVQ_PLAYLIST}"
  for f in *.json; do
    jsonlink "$f" >> "$playlist";
    printf "\n" >> "$playlist";
  done
  return 0
}

metadb_search() {
  metadb="$HOME/Videos/yt/metadb.json"
  search="$*"
  jq -r '.[] | select(.title, .description | contains("'$search'"))' "$metadb" | jq -r '.path'| sort -u | nsxiv -
}

sxyt() {
  search="$*"
  metadb="$HOME/Videos/yt/metadb.json"
  playlist="$HOME/.playlist""$HOME/Videos/playlists/adhoc/$(printf "$search" | sed 's/[[:space:]]/_/g').m3u8"
  tmp=$(mktemp)
  jq -r '.[] | select(.title, .description | contains("'$search'"))' "$metadb" | jq -r '.path'|  sort -u | nsxiv -tio >> "$tmp"
  while read -r f; do
      exiftool -s3 -UserComment "$f" | jq -r '"\(.Summary.URI // .URI) # \(.Summary.Title // .Title)"' >> "$HOME/Videos/playlists/adhoc/$(printf "$search" | sed 's/[[:space:]]/_/g').m3u8"
  done < "$tmp"
  rm "$tmp"
  trap 'kill $pid' INT HUP EXIT
  reload_playlist &
  pid=$!
  stnvim "$playlist" &
  linkhandler "$playlist"
}

aicat() {
  for f in "$@"; do
    if [ -f "$f" ]; then
      fname=$(basename "$f")
      file=$(cat "$f")
      printf '```%s\n%s\n```\n' "$fname" "$file"
    else
      echo "File not found: $f"
    fi
  done
}

aiecho() {
    [ -n "$*" ] && printf '```%s\n%s\n```\n' "${0}" "$*"
}

epoch2date() {
  if [ -z "$1" ]; then
    echo "Syntax:   epoch2date <epoch_time> [format]"
    echo "Default format:  %A, %B %d, %Y %H:%M:%S %Z"
    echo "Example:"
    echo "  \$ epoch2date 1483277086 \"%A, %Y-%m-%d %H:%M:%S\""
    echo "  --> dimanche, 2017-01-01 08:24:46"
    echo " (default output: dimanche, janvier 01, 2017 08:24:46 EST)"
    return 1
  fi
  format=${2:-"%A, %B %d, %Y %H:%M:%S %Z"}
  date -d @"$1" +"$format"
}

getfailedids() {
  [ ! -f  "$1" ] && echo "File not found" && return 1
  out=${2:-./failed}
  while read -r line; do
      echo "https://www.youtube.com/watch?v=$line" >> "$out"
  done < <(grep 'ERROR:' "$1" | cut -d']' -f2  | cut -d':' -f1)
  mv "$out" "$1.$(date +%Y%m%d%H%M%S)"
}

diffln() {
  echo "Files in $1 but not in $2"
  diff -rq <(find "$1" -type f) <(find "$2" -type l)
}

ffmpeg2messenger() {
    in="$1"
    out="${2:-fb_${in%.*}.mp4}"
    basename=$(basename "$in")
    realout=$(realpath "$out")
    ffmpeg -i "$in" -c:v libx264 -preset slow -crf 20 -profile:v high -level 4.1 -pix_fmt yuv420p \
      -vf "scale='min(1280,iw)':'min(ih*1280/iw,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2,fps=30" \
      -b:v 3000k -maxrate 3000k -bufsize 6000k -c:a aac -b:a 192k -ar 44100 -strict experimental -movflags +faststart -fs 24M "$out" -y
    echo "$basename --> $out"
    echo "$realout" | xclip -selection clipboard && echo "$realout copied to clipboard"
    return 0
}

relink() {
  ls | grep '"' | while read -r file; do
    mv -- "$file" "$(echo "$file" | sed 's/"/'\''/g')"
  done
}

mtdcnt() {
    find "$HOME/Videos/yt/meta" -maxdepth 1 \
         -not -path "$HOME/Videos/yt/meta/imported" \
         -not -path "$HOME/Videos/yt/meta/playlists" \
         -not -path "$HOME/Videos/yt/meta/bookmarks" \
         -type d -exec echo "{}" \; > .metadirs
    C=$(wc -l < .metadirs)
    echo ${C}
}

ythb() {
    D=$(mtdcnt)
    J=$((D*3))
    parallel -j0+"$J" nsxiv "{}" -sF < .metadirs |\
        parallel -0 -j0+"$J" -I {} exifjpg -M "{}" > "{}".playlist |\
        mpv --playlist="{}".playlist &
}

lnescape() {
    title="$1"
    saneln=$(echo "$title" | sed 's/[\/:]//g; s/  / /g; s/^ //; s/\"/'\''/g')
    #  echo "$title"
    #  echo "$saneln"
    mv "$title" "$saneln"
}

readexif() {
    f="$1"
    [ -L "$f" ] && f="$(readlink -f "$f")"
    fi=$(realpath "$f")
    {
        read -r channel
        read -r title
        read -r uri
      } < <(exifjpg -ctu "$fi")
    echo "$channel $title $uri"
}

timestamp() {
  [ $# -gt 0 ] && CLIP=1
  [ "$CLIP" -eq 1 ] && date "+%Y-%m-%d %H:%M:%S" | xclip -selection clipboard
  date "+%Y-%m-%d %H:%M:%S" ;
}

exdt() { t="$1"; f="${2:-ar}" ; exifjpg -"$f" "$t" 2>/dev/null ; }

ytlnup() {
  v="$1"
  vu="$(exifjpg -u "$v")"
  vup="$(exifjpg -U "$v")"
  errdir="$HOME/Videos/failed"
  [ -d "$errdir" ] || mkdir -p "$errdir"
  channel=${vup#https://www.youtube.com/@}
  touch "$errdir/$channel.err"
  ytup "$vu" && ytln "$vup" 2>"$errdir/$channel.err"
}

trimbl() { for f in "$@"; do [ -f "$f" ] && sed -i '/^$/d' "$f" ; done ; }

mplist() {
  mpc playlist |nl| while read -r l ; do
     title="$(echo "$l"|awk '{print $2}')"
     stream=$(grep -Fx "$title" "$HOME/.cache/mpd-streams")
     i=$(echo "$l"|awk '{print $1}')
  if [ -n "$stream" ]; then
     sid=$(grep -nFx "$title" "$HOME/.cache/mpd-streams" | awk -F: '{print $1}')
     t=$(sed -n "${sid}p" "$HOME/.cache/mpd-title")
     printf "%s      %s\n" "$i" "$t"
   else
     printf "%s\n" "$l"
   fi
  done
}

mp() {
  case "$1" in
    -l|--list)
      mplist ;
      notify-send -a "mpctl" -r 9998 -t 2000 "$(mplist)" ;
      return;;
    -c|--clear)
      :> ~/.cache/mpd-title
      :> ~/.cache/mpd-streams
      mpc clear && echo "clair."
      return;;
    -v|--voice)
      playmuse
      return;;
    -n|--next)
      mpc next >/dev/null 2>&1
      return 0;;
    -p|--prev)
      mpc prev >/dev/null 2>&1
      return;;
    -d|--delete)
      index="$2"
      [ -n "$index" ] || { echo "Specify an index" >&2; return 1 ; }
      title=$(mpc playlist | sed -n "${index}p")
      stream=$(grep -Fx "$title" "$HOME/.cache/mpd-streams")
      if [ -n "$stream" ]; then
         sid=$(grep -nFx "$title" "$HOME/.cache/mpd-streams" | awk -F: '{print $1}')
         t=$(sed -n "${sid}p" "$HOME/.cache/mpd-title")
         sed -i "${sid}d" ~/.cache/mpd-streams
         sed -i "${sid}d" ~/.cache/mpd-title
         printf "%s *removed*\n" "$t"
       else
         printf "%s *removed*\n" "$title"
       fi
       mpc del "${index}" >/dev/null 2>&1
       mplist
       return;;
    -dl|--download)
      index="$2"
      [ -n "$index" ] || { echo "Specify an index" >&2; return 1 ; }
      title="$(mpc playlist | sed -n "${index}p")"
      stream=$(grep -Fx "$title" "$HOME/.cache/mpd-streams")
      if [ -n "$stream" ]; then
         sid="$(grep -nFx "$title" "$HOME/.cache/mpd-streams" | awk -F: '{print $1}')"
         t="$(sed -n "${sid}p" "$HOME/.cache/mpd-title")"
         link=$(grep -F "$t" "$HOME/Downloads/albums/history.playmuse" | awk -F' # ' '{print $1}'| sort -u)
         ydl -a "$link"
       else
         mplist
         echo "$title is local."
         return 1
      fi
      return;;
    *) query="$*" ;;
  esac
  museplay "$query" >/dev/null && \
  mplist
  return 0
}

mediainf() {
  f="$1"
  mediainfo_output=$(mediainfo "$f")
  album=$(echo "$mediainfo_output" | grep -E "Album" | cut -d: -f2 | xargs)
  title=$(echo "$mediainfo_output" | grep -E "Track name" | cut -d: -f2 | xargs)
  position=$(echo "$mediainfo_output" | grep -E "Track name/Position" | cut -d: -f2 | xargs)
  artist=$(echo "$mediainfo_output" | grep -E "Performer" | cut -d: -f2 | xargs)
  date=$(echo "$mediainfo_output" | grep -E "Recorded date" | cut -d: -f2 | xargs)
  echo "Album: $album"
  echo "Title: $title"
  echo "Position: $position"
  echo "Artist: $artist"
  echo "Date: $date"
}

is_urljpg() {
  f="$(realpath "$1")"
        [ -f "$f" ] || { echo "that's not a file."; return 1 ; }
        if file --dereference --mime-type --brief "$f" | grep -q "image/jpeg" && [ -n "$(exifjpg -u "$f" 2>/dev/null)" ]; then
            url=$(exifjpg -u "$f")
            [ -n "$url" ] && echo "$url" || return 1
        fi
        return 0
}

gecho() { grep -qE "$1" "$2" || echo "$1" >> "$2" ; }

grepecho() {
  op="tee -a"
  SOURCE=0
  while getopts "sS" opt; do
    case $opt in
      s) op=">>" ;;
      S) SOURCE=1 ;;
      *) op="tee -a" ;;
      ?) echo "Invalid option: -$OPTARG" >&2; return 1 ;;
    esac
  done
  shift "$((OPTIND - 1))"
  grep -qE "$1" "$2" || echo "$1" | eval "$op" "$2"
  [ "$SOURCE" -eq 1 ] && source "$2" >/dev/null 2>&1
}

addalias() {
  alias_f="${XDG_CONFIG_HOME:-$HOME/.config}/shell/aliases"
  ln_cnt=$(wc -l < "$alias_f")
  ln_ellipsis=$((ln_cnt - 8))
  printf "alias %s='%s'" "$1" "$2" >> "$alias_f"
  nl -ba "$alias_f" | head -n8 | sed 's/\([0-9]\)/ /' ;
  printf "   (%s) [...]\n" "$ln_ellipsis" ;
  nl -ba "$alias_f" | tail -n4 ;
  source "$alias_f" >/dev/null 2>&1
}

fn_echo() {
  func="$*"
  func_escaped=$(printf '%s' "$func" | sed 's/[&/\]/\\&/g')
  # echo "$func"
  echo "$func_escaped"
}

addfn() {
  func_f="${XDG_CONFIG_HOME:-$HOME/.config}/shell/functions"
  ln_ellipsis=$((ln_cnt - 8))
  func="$*"
  func_escaped=$(printf '%s' "$func" | sed 's/[&/\]/\\&/g')
  # sed -i "${penultimate_line}i \n${func_escaped}" "$func_f"
  printf "%s\n\n" "$func_escaped" >> "$func_f"
  func_name=$(echo "$func" | head -n1 | awk -F'(' '{print $1}')
  sed -i "${ln_cnt}d" "$func_f" >/dev/null
  # echo "$func_escaped"
  if ! source "$func_f" >/dev/null 2>&1; then
    echo "Error: Sourcing the function file failed. Removing the added function."
    sed -i "/^${func_escaped}$/d" "$func_f"
    echo "$func_name removed from $func_f."
    return 1
  fi
  head="$(nl -ba "$func_f" | head -n8)"
  ellipsis="$(printf "\n  [%s] (...)\n\n" "$ln_ellipsis")"
  tail="$(nl -ba "$func_f" | tail -n10)"
  printf "       %s\n%s\n%s\n\n%s -> %s\n" "$head" "$ellipsis" "$tail" "$func_name" "$func_f"
}

extinfpipe() {
    exifjpg -gtu "$1" | {
    read -r d ; read -r t ; read -r u ;
    s=$(echo "$d" | awk -F: 'NF==3 {print $1*3600+$2*60+$3}; NF==2 {print $1*60+$2}; NF==1 {print $1}')
    printf "#EXTINF:%s,%s\n%s\n" "$s" "$t" "$u"
  }
}

has_hls_header() { sed -n "1p" "$1" | grep -q "^#EXTM3U" || sed -i "1i #EXTM3U" "$1" ; }

timestamp_format() {
  in="$1"
  out=${2:-timestamps}
  [ -f "$in" ] || { echo "File not found" >&2; return 1 ; }
  while read -r l; do
    t=$(echo "$l" | cut -d' ' -f1 | awk -F: '{
      if (NF == 3) printf "%02d:%02d:%02d", $1, $2, $3;
      else if (NF == 2) printf "00:%02d:%02d", $1, $2;
      else if (NF == 1) printf "00:00:%02d", $1;
    }')
    c=$(echo "$l" | cut -d' ' -f2-)
    printf "%s\t%s\n" "$t" "$c"
  done < "$in" > "$out"
  tail "$out"
}

m3u_sdpipe() {
   f="$1"
   sd="${2:-/tmp/mpv.sock}"
   playlist="${3:-$HOME/.cache/mpvq/sd_mpvq.m3u8}"
   titles="${4:-$HOME/.cache/mpvq/sd_mpvq.titles}"
   grep -v "#EXTM3U" "$f" | while read -r e; do
      read -r u
      [ -z "$e" ] || [ -z "$u" ] && continue
      t=$(echo "$e" | sed -n 's/#EXTINF:\([0-9]*\),\(.*\)/\2/p')
      grep -qE "$t" "$titles" || echo "$t" >> "$titles"
      grep -qE "$u" "$playlist" || { echo "$e" ; echo "$u" ; } >> "$playlist"
      echo '{"command": ["loadfile", "'"$u"'", "append"]}' | socat - "/tmp/mpv.sock"
   done || return 1
   return 0
}

m3umpsd() {
   f="$1"
   u="/tmp/filtered.m3u8"
   sd="${MPV_SOCK:-/tmp/mpv.sock}"
   grep -v "#EXT" "$f" > "$u"
   echo '{"command": ["loadlist", "'"$u"'", "append"]}' | socat - "$sd"
   rm -f "$u"
}

hlsfzsd() {
   f="$1"; sd="/tmp/mpv.sock";
   grep -v "#EXT" "$f" | fzf --multi | while read -r e; do
       read -r u
       [ -z "$e" ] || [ -z "$u" ] && continue
       echo '{"command": ["loadfile", "'"$u"'", "append"]}' | socat - "$sd"
   done
}

sort_playlist_bydate() {
  playlist="$1"
  awk '
  BEGIN { OFS = "\t" }
  /^#EXTINF/ {
    match($0, /[0-9]{4}-[0-9]{2}-[0-9]{2}$/, match_array)
    date = (match_array[0] != "") ? match_array[0] : "0000-00-00"
    extinf = $0  # Store the #EXTINF line
    getline link  # Read the associated link
    if (link ~ /^https?:\/\//) {
      print date, extinf, link
    } else {
      print date, extinf
    }
  }
  ' "$playlist" | sort -t$'\t' -k1,1 | awk -F'\t' '
  {
    # Reformat output with aligned #EXTINF and URL
    print $2
    if (NF == 3) print $3
  }
  '
}

dir_name() {
  t="$1"
  if [ -f "$t" ]||[ -L "$t" ]; then
    d=$(dirname "$t")
  elif [ -d "$t" ]; then
    d="$(realpath $t)"
  fi
  name=$(basename "$(realpath "$d")")
  echo "$name"
}

# make_playlist() {
#   name=$(basename "$(dirname "$1")")
#   for f in *; do
#     exifjpg -M "$f" 2>/dev/null || continue
#   done > "$HOME/Videos/playlists/$name.m3u8"
#   has_hls_header "$HOME/Videos/playlists/$name.m3u8"
#   grep "#EXTINF" | wc
#   echo "$name playlist created."
# }

error() { cond="$1"; msg="$2" ; eval "$cond" && echo "$msg" && return 1 ; }

make_playlist() {
  playlist="$1"
  for f in *; do
    [ -n $(is_urljpg "$f") ] || continue
    exifjpg -M "$f" >/dev/null 2>&1 | while read -r l; do
       grep "$l" "$playlist" || echo "$l" >> "$playlist"
      done
  done
  has_hls_header "$playlist"
  grep "#EXTINF" "$playist" | wc -l
  echo "$playlist created."
}

make_all_playlists() {
    for d in "$HOME/Videos/yt/meta/"*; do
        if [ -d "$d" ]; then
            case "$d" in
               *bookmarks|*null|*imported) continue ;;
               *) name=$(basename "$d" | sed "s/ $//;s/ /_/g;s/\.//g;s/'//g;s/\,//g;s/&/and/g")
                  for f in "$d"/*.jpg; do
                      exifjpg -M "$f" 2>/dev/null
                  done > "$HOME/Videos/playlists/${name}.m3u8"
                  [ -f "$HOME/Videos/playlists/${name}.m3u8" ] && has_hls_header "$HOME/Videos/playlists/${name}.m3u8"
                  vcount=$(grep -Ec "^#EXTINF" "$HOME/Videos/playlists/${name}.m3u8")
                  echo "$name playlist created (${vcount} videos)"
                  ;;
            esac
        fi
    done
}

dname() {
  t="$1";
  d=$(dirname "$t")
  r=$(realpath "$t")
  n=$(basename "$r")
  dn=$(basename "$d")
  printf 't="$1"              => target:      %s\n' "$t"
  printf 'r=$(realpath "$t")  => realpath:    %s\n' "$r"
  printf 'd=$(dirname "$t")   => dirname:     %s\n' "$d"
  printf 'n=$(basename "$r")  => basename:    %s\n' "$n"
  printf 'dn=$(basename "$d") => dirbasename: %s\n' "$dn"
  return 0;
}

for_f() {
  in="$*"
  cmd="$1"
  pat="$2"
  args=("$@")
  arg=$(echo "${args}"|sed "s/$1 $2 //")
  for f in *"$pat"; do "$cmd" "$f" "$arg" 2>/dev/null ; done
}

f_ext() { f="$1" ; ext=${f##*.} ; [ -n "$ext" ] && echo "$ext" || return 1 ; return 0 ; }
twitch() { while read -r sub; do ttv "$sub" 2>/dev/null ; done < ~/Videos/ttvsubs ; }
sce() { # fuzzy script edit
    scpath=${1:-"$HOME/.local/bin"}
    s=("$scpath"/*)
    c="$(print -lnr ${s:t:r} | fzf)"
    [ "${c}" ] && emc ${${(M)s:#*/${c}*}[1]}
}

lambda() {
  f="$HOME/.config/shell/functions"
  n="$1" ; b=$(echo "$*" | cut -d' ' -f2-) ;
  l=$(wc -l < \"$f\"); i=$((l-1))
  fn="${n}() { ${b} ; }"
  sed -i "${i}i $fn" "$f"
  head -n8 "$f" ; tail -n5 "$f" ;
}

mpsd_loadlist() {
  f="$1"
  u="/tmp/m3u8.tmp"
  grep -v "#EXT" "$f" > "$u"
  [ -f "$u" ] && echo '{"command": ["loadlist", "'"$u"'", "append"]}' | socat - "/tmp/mpv.sock" >/dev/null 2>&1
  rm -f "$u" >/dev/null 2>&1 ;
}

sort_playlist_byduration() {
    playlist="$1" ;
    awk '
    BEGIN { OFS = "\t" }
    /^#EXTINF/ {
        # Extract duration, title, and date
        match($0, /^#EXTINF:([^,]+),([^,]+),([^,]+)/, match_array)
        duration = match_array[1] + 0
        title = match_array[2]
        date = match_array[3]

        extinf = $0  # Store the #EXTINF line
        getline link  # Read the associated link
        if (link ~ /^https?:\/\//) {
            print duration, extinf, link
        } else {
            print duration, extinf
        }
    }
    ' "$playlist" | sort -t$'\t' -k1,1n | awk -F'\t' '
    {
        # Reformat output with aligned #EXTINF and URL
        print $2
        if (NF == 3) print $3
    }
    ' ;
}

logdbg() {
    input="$*"
    DBG=1
    LOGDIR="$HOME/Templates/logs"
    LOGFILE="$LOGDIR/dbg.log"
    [ -d "$LOGDIR" ] || mkdir -p "$LOGDIR"
    [ -f "$LOGFILE" ] || touch "$LOGFILE"
    sid=${sid:-"${0##*/}"}
    [ "$DBG" -eq 0 ] && eval "$("$input")" 2>&1 && return 0
    timestamp=$(date -u +"%Y-%m-%d %H:%M:%S")
    printf "[%s] (%s) %s\n" "$timestamp" "${0}" "$(eval "$input" 2>>"$LOGFILE" 2>&1)" 2>&1 >> "$LOGFILE" ;
    # l=$(wc -l < "$LOGFILE"); i=$((l-3)); sed -i "${i}d" "$LOGFILE" && tail -n1 "$LOGFILE"
    awk '/^\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\]/' "$LOGFILE" > "$LOGFILE.tmp" && \
      mv -f "$LOGFILE.tmp" "$LOGFILE" >/dev/null 2>&1 ;
}

ff_infojs_embed() {
  for i in *.info.json; do
    title=${i%%.info.json}
    ls "${title}".{mp4,webm,mkv} 2>/dev/null | while read -r t ; do
        ffjsonembed "$t" "$i"
      done
  done
  return 0;
}

figlets() {
    string="$*"
    fonts=(banner block digital lean mnemonic shadow small smshadow standard big bubble ivrit mini script slant smscript smslant term)
    for font in $fonts; do
        echo "$font"
        figlet -f "$font" "$string"
        echo
    done
}

fatdirs() {
   d=${1:-$HOME}
   i=${2:-10}
   [ -d "$d" ] && du -Sh "$d" 2>/dev/null | sort -rh | head -n "$i"
   return 0
}

mklocalplaylist() {
    d=${1:-.} ;
    [ -d "$d" ] || d=$(dirname "$d") ;
    playlist="$HOME/$(basename "$d" | sed -e "s/ /-/g;s/[\&/\`\\*.$ ']//g")_$(date +"%Y-%m-%d_%H%M-%S").m3u8" ;
    find "$d" -type f -name "*[webm|mkv|mp4|avi|mpeg4|mpeg|mov]" |\
        while read -r f; do
           if [ $(file --brief --mime-type "$f") = "video/*" ]; then
               extinf_video_cat "$f" 2>/dev/null
           fi
        done >"$playlist" ; has_hls_header "$playlist" && linkhandler "$playlist" ;
}

mkjpgplaylist() {
    d=${1:-.};
    [ -d "$d" ] || d=$(dirname "$d");
    playlist="$HOME/$(basename "$d" | sed -e "s/ /-/g;s/[\&/\`\\*.$ ']//g")_$(date +"%Y-%m-%d_%H%M-%S").m3u8" ;
    find "$d" -type l | while read -r f; do
           if [ $(file --dereference --brief --mime-type "$f") = "image/jpeg" ]; then
               exifjpg -M "$f" 2>/dev/null
           fi
        done >"$playlist" ;
    has_hls_header "$playlist" && linkhandler "$playlist" ;
}

askchar() {
    stty -echo -icanon
    char=$(dd bs=1 count=1 2>/dev/null)
    stty sane
    echo "$char"
}

whut() {
    dis="$1"
    type "$dis" | while read -r t; do
        case "$t" in
            "*not found")
                printf "%s -- Create it now? " "$t" ;
                askchar | grep -qi "[y,o]" && {
                    printf "OÃ¹?  "
                    read -r dir
                    [ -d "$dir" ] || mkdir -p "$dir"
                    emc "$dir/$dis" || { echo "Invalid directory" >&2 ; return 1 ; }
                    return 0
                }
                ;;
            *alias*) findalias "$dis" ; return 0 ;;
            "*is a shell function from*")
                echo "$t" | awk -F"$dis is a shell function from " '{print $2}' | while read -r f; do
                    [ -f "$f" ] || { echo "$f is not a file" >&2 ; return 1 ; }
                    line=$(grep -n "$dis" "$f"|cut -d ':' -f1)
                    [ -n "$line" ] && emc +"${line}" "$f" || emc "$f" || { echo "emc +${line} ${f}" >&2 ; return 1 ; }
                done
                return 0
                ;;
            *) f=$(find "$HOME" -path "$HOME/.config/*" -path "$HOME/.local/bin/*" -path "$HOME/.local/*" -type f -iname \*"$dis"\*)
               t=$(echo "$f" | awk -F' ' '{print $1}'| head -n1)
               [ -f "$t" ] && emc "$t" || { echo -e "failed to open $t\nfound: $f" >&2 ; return 1 ; }
               return 0
               ;;
        esac
    done
    return 0
}

printargs() {
    shift
    while [ $# -gt 0 ]; do
        printf " %s" "$1"
        shift
    done
}

# dynamic variable expansion test function
# usage: echovars <test_arg> -- '<vardec1=vardef1>' '<vardec2=vardef2>' '<...>'
echovars() {
    test="$1"
    shift
    for expr in "$@"; do
        eval "$(echo "$expr" | sed "s|\$1|\"$test\"|g")"
    done
    for expr in "$@"; do
        # Extract the variable name (before '=')
        var_name="${expr%%=*}"
        eval "value=\"\$$var_name\""
        printf "%s => %s\n" "$var_name" "$value"
    done
}

vm() {
    vm_dir="$HOME/Templates/vm"
    find "$vm_dir" -type f -name "*.conf" | fzf | xargs -I{} quickemu --vm "{}" --display "spice" --width "2256" --height "1504" || return 1 ;
    return 0;
}

xswl() {
    REVERSE=0
    while getopts "rh" opt; do
        case "$opt" in
            r) REVERSE=1 ; break ;;
            h|*) echo "xswl -[r] reverse SWALLOWER-SWALLOWEE -[h|*] prints this." && return 1 ;;
        esac
    done
    i="$WINDOWID"
    t=$(xwininfo | grep -E "Window id: " | awk '{print $4}')
    [ "$REVERSE" -eq 1 ] && { dwmswallow "$t" "$i" || return 1 ; } && return 0
    dwmswallow "$i" "$t" || return 1
    return 0
}

fc-cache-rv() {
    (fc-cache -rv && sudo fc-cache -rv && wmreup) || return 1
    return 0
}

strprint() {
    FS=" "
    while getopts "F:" opt; do
        case "$opt" in
            F) FS="$OPTARG" ; break ;;
            *) ;;
        esac
    done
    FS=${FS[1]}
    echo "$@" | awk -F"$FS" '{for (i=0;i<=NF;i++) {print "\""$i"\""}}'
}

svadd() {
    [ $# -gt 0 ] || { printf "svadd <service>\n\t\t => sudo ln -s /run/runit/sv/<service> /run/runit/service\n" ; return 1 ; };
    for sv in "$@" ; do
        [ -n "$sv" ] || { echo "Error while reading service. Got: '${sv}'" ; continue }
        [ -d "/etc/runit/sv/$sv" ] || { echo "Could not find $sv in service directory. Is it installed?" ; continue ; }
        [ -L "/etc/runit/sv/$sv" ] && { echo "$sv is already linked as running service." ; sudo sv status "$sv" 2>&1 } ; continue  || continue
        if sudo ln -s /etc/runit/sv/"$sv" /run/runit/service ; then
            sudo sv status "$sv"
        else
            echo "Error while linking $sv. Verify installation and runscript." >&2
        fi
        continue
    done
    return;
}

YTZD="$HOME/Videos/playlists/ytzf"
YTZF="$YTZD/.saved"
[ -d "$YTZD" ] || mkdir -p "$YTZD"
[ -f "$YTZF" ] || touch "$YTZF"
export YTZD
export YTZF

fzfbm() {
    pf="${1:-$YTZF}"
    cat "$pf" | fzf --delimiter="\t" --with-nth=1 | while read -r n f; do
        [ -n "$n" ] && [ -f "$f" ] || return 1 ;
        if tmux has-session -t mpv || tmux new-session -d -s "mpv" ; then
            tmux new-window -t mpv: -n "$n" -- "/usr/bin/mpv -quiet --playlist=${f} 2>&1"
        else
            echo "failed to create in tmux session... starting $selected_playlist detached.."
            setsid -f /usr/bin/mpv -quiet --playlist="$f" 2>&1 || return 1 ;
        fi
    done
    return;
}

#  mkpl() {
#      unset i n p
#      i=0 ; n=0 ; p=0 ; q=0
#      while getopts "n:ipq" opt; do
#          case "$opt" in
#              n) n=1 ; name="$OPTARG" ;;
#              i) i=1 ;;
#              p) p=1 ;;
#              q) q=1 ;;
#              *) ;;
#          esac
#      done
#      shift $(($OPTIND - 1))
#      DNAME="$(basename "$(pwd)"| sed 's/ /-/g')_$(date +"%Y-%m-%d_%H%M-%S").m3u8"
#      cpl=${1:-"$DNAME"}
#      cpl=${cpl%.m3u8}.m3u8
#      [ -f "$cpl" ] || echo "#EXTM3U" >"$cpl"
#      find . -maxdepth 1 -mindepth 1 | while read -r l ; do
#          case $(file --dereference --brief --mime-type "$l") in
#              video*) extinf_video_cat "$l" 2>/dev/null | tee -a "$cpl" || continue ;;
#              image/jpeg) exifjpg -M "$l" 2>/dev/null | tee -a "$cpl" || continue ;;
#              *) continue ;;
#          esac
#      done
#      head -n 1 "$cpl" | grep -q "#EXTM3U" || sed -i "1i #EXTM3U" "$cpl"
#      [ -z "$name" ] && name="$(basename "$(pwd)"| sed "s/ /-/g;s/\'//g")"
#      lnc=$(grep -c "#EXTINF" "$cpl")
#      realpath "$cpl" | xclip -in -selection clipboard
#      echo "$lnc videos added to $cpl. Path to playlist added to clipboard."
#      if [ "$i" -eq 1 ] ; then
#          echo "Add to ${PLAYLIST_LIST##*/} playlists? [Y/n]"
#          stty -echo -icanon
#          ans=$(dd bs=1 count=1 2>/dev/null)
#          stty sane
#          [ "$ans" = "y" ] && echo "Change Name? (AliasName: $name)"
#          stty -echo -icanon
#          n=$(dd bs=1 count=1 2>/dev/null)
#          stty sane
#          [ "$n" = "y" ] && echo "NewAliasName: " && read -r name
#      fi
#      [ -n "$name" ] && echo "Name: $name" && mv "$cpl" "$PLAYLIST_DIR"
#      printf "%s\t%s\n" "$name" "$PLAYLIST_DIR/$cpl" >>"$PLAYLIST_LIST"
#      echo "You can recall and launch previously saved playlists by calling fzfmpl."
#      unset name
#      [ "$i" -eq 0 ] && return 0
#      [ -f "$YTZF/$cpl" ] && playlist="$PLAYLIST_DIR/$cpl" || playlist="$cpl"
#      [ "$i" -eq 1 ] || [ "$p" -eq 0 ] && {
#          echo "Play Now? [Y/n]"
#          stty -echo -icanon
#          ans=$(dd bs=1 count=1 2>/dev/null)
#          stty sane
#          [ "$ans" = "n" ] && echo "$playlist. done." && return 0
#      }
#      if grep "$PLAYLIST_DIR/$cpl" "$PLAYLIST_LIST" ; then
#          tail -n 1 "$PLAYLIST_LIST" | while read -r n f ; do
#              if tmux has-session -t mpv >/dev/null 2>&1 || tmux new-session -d -s "mpv" ; then
#                  tmux new-window -t mpv: -n "$n" -- "/usr/bin/mpv -quiet --playlist=${f} 2>&1"
#              else
#                  echo "failed to create in tmux session... starting $selected_playlist detached.."
#                  linkhandler "$f" || return 1 ;
#              fi
#          done
#      fi
#      return 0
#  }

tmxzf() {
    ls ~/Videos/playlists | while read -r t; do b=${t##*/} ; n=${b%.*} ; printf "%s\t%s\n" "$n" "$HOME/Videos/playlists/$t" ; done | fzf --delimiter="\t" --with-nth=1 | while read -r n f ; do
        [ -n "$n" ] && [ -f "$f" ] || return 1 ;
        if tmux has-session -t mpv >/dev/null 2>&1 || tmux new-session -d -s "mpv" ; then
            tmux new-window -t mpv: -n "$n" -- "/usr/bin/mpv -quiet --playlist=${f} 2>&1"
        else
            echo "failed to create in tmux session... starting $selected_playlist detached.."
            setsid -f /usr/bin/mpv -quiet --playlist="$f" 2>&1 || return 1 ;
        fi
    done
}

mkdpl() {
    PLDIR=${YTZD:-"$HOME/Videos/playlists/ytzf"}
    SAVED=${YTZF:-"$HOME/Videos/playlists/ytzf/.saved"}
    [ -d "$PLDIR" ] || mkdir -p "$PLDIR"
    [ -f "$SAVED" ] || touch "$SAVED"
    [ $# -lt 1 ] || [ ! -d "$1" ] && d=$(find "$HOME/Videos/yt/" -maxdepth 1 -mindepth 1 -type d -not -path "/home/cf/Videos/yt/meta" | fzf --delimiter='/' --with-nth=6) || d="$1"
    p=$(echo "${d##*/}" | sed "s/ /-/g;s/'//g")
    pl="$HOME/Videos/playlists/ytzf/${p}.m3u8"
    find "$d" -mindepth 1 -maxdepth 1 -type l | while read -r l ; do
        exifjpg -M "$l" 2>/dev/null | tee -a "$pl" || continue
    done
    [ -f "$pl" ] && head -n1 "$pl" | grep -q "#EXTM3U" || sed -i "1i #EXTM3U" "$pl"
    vcount=$(grep -c "#EXTINF" "$pl")
    if [ -f "$pl" ] && [ "$vcount" -gt 1 ]; then
        printf "%s\t%s\n" "$p" "$pl" | tee -a "$SAVED" && echo "Piped $vcount videos in $p playlist. done."
        unset p pl vcount
    else
        unset p pl vcount
        return 1
    fi
    return 0
}

dic_pick() { sdcv -l | awk -F"    " '{print $1}' | fzf --multi ; }
whichcat() { t="$1" ; f=$(which "$t") ; [ -f "$f" ] && cat "$f" || return 1 ; }

h2t() {
    [ $# -eq 2 ] || { echo "Usage: h2t <max> <step_count>" ; }
    m=$1 ; t=$2 ; [ "$m" -lt "$t" ] && m=$2 && t=$1 ;
    s=$((m / t)) ; r=$((m % t)) ;
    for i in $(seq 1 "$t") ; do
        v=$((i * s + (i * r / t)))
        printf " $v"
    done ; echo
}

adbreset() {
    adb kill-server ; adb start-server ;
    if adb devices -l ; then
        adb tcpip 5555
    else
        adb reconnect offline
    fi
}

ssh_to() {
    t=$(grep -iE '^(host)\s? ' ~/.ssh/config| sed 's/^Host //;s/[[:space:]]//g' | fzf)
    [ -n "$t" ] && ssh "$t" || return 1
    return 0
}

bthc() {
    if [ $# -lt 1 ]; then
        set -- $(printf 'sonos\nhd440\nlaurence\nkeychron\nfrancoSoundBar\nchambly\n' | fzf --multi)
    fi
    cnt=0
    argc=$#
    for d in "$@"; do
        cnt=$((cnt+1))
        printf '%d/%d\tBT connection to: %s ... ' "${cnt}" "${argc}" "$d"
        case "$d" in
            s*) # sonos
                { bluetoothctl connect "F0:F6:C1:D1:B9:74" >/dev/null && printf 'done' ; } || { printf 'failed' >&2 ; continue ; } ;;
            h*)  # hd440
                { bluetoothctl connect "00:16:94:25:13:35" >/dev/null && printf 'done' ; } || { printf 'failed' >&2 ; continue ; } ;;
            l*)  # laurece btk
                { bluetoothctl connect "16:77:6F:3E:2C:EE" >/dev/null && printf 'done' ; } || { printf 'failed' >&2 ; continue ; } ;;
            k*)  # kc
                { bluetoothctl connect "DC:2C:26:0C:F0:5F" >/dev/null && printf 'done' ; } || { printf 'failed' >&2 ; continue ; } ;;
            f*)  # francoSB
                { bluetoothctl connect "54:15:89:92:1B:52" >/dev/null && printf 'done' ; } || { printf 'failed' >&2 ; continue ; } ;;
            c*)  # chamblySB
                { bluetoothctl connect "C4:30:18:AE:2A:C3" >/dev/null && printf 'done' ; } || { printf 'failed' >&2 ; continue ; } ;;
            *)  continue ;;
        esac
    done
    return 0
}


m3u8_sort_ascending() {
    unset b d f n t p
    d="$HOME/Videos/playlists/date_time_ascending"
    [ -d "$d" ] || mkdir -pv "$d"
    f="$1" ; [ -f "$f" ] || { echo "$f is not a file" >&2 ; return 1 ; }
    if [ "$(file --dereference --mime-type --brief "$f")" = "audio/x-mpegurl" ] ; then
        b=${f##*/} ; n=${b%.*} ; p="$d/${n}_chron.m3u8" ; t=$(mktemp)
        sed '1d' "$f" >"$t"
        awk 'NR%2{h=$0; next} { print h","$0 }' "$t" | \
            awk -F, '{ print $0 | "sort -t, -k3,4" }' |\
            awk -F, '{print $1","$2","$3"\n"$4 }' >"$p"
        sed -i '1i #EXTM3U' "$p" && echo "$p"
    fi
    unset b d f n t p
    return 0
}

m3u8_sort_descending() {
    unset b d f n t p
    d="$HOME/Videos/playlists/date_time_descending"
    [ -d "$d" ] || mkdir -pv "$d"
    f="$1" ; [ -f "$f" ] || { echo "$f is not a file" >&2 ; return 1 ; }
    if [ "$(file --dereference --mime-type --brief "$f")" = "audio/x-mpegurl" ] ; then
        b=${f##*/} ; n=${b%.*} ; p="$d/${n}_rchron.m3u8" ; t=$(mktemp)
        sed '1d' "$f" >"$t"
        awk 'NR%2{h=$0; next} { print h","$0 }' "$t" | \
            awk -F, '{ print $0 | "sort -t, -k3,4r" }' |\
            awk -F, '{print $1","$2","$3"\n"$4 }' >"$p"
        sed -i '1i #EXTM3U' "$p" && echo "$p"
    fi
    unset b d f n t p
    return 0

}

upfw() {
    sudo sv restart nftables
    sudo sv restart ufw
    sudo nft flush ruleset
    sudo nft -f /etc/nftables.conf
    sudo ufw enable
    sudo ufw reload
    for ip in "$@" ; do
        { sudo ufw status numbered ; sudo nft list ruleset ; } | grep "$ip"
    done
}

addssh_host() {
    dev="$1" ;
    sudo ufw allow from "$dev" to any port 22 ;
    sudo ufw reload ; sudo sv restart ufw ;
    sudo ufw status numbered | grep "$dev"
}

uphost() {
    [ $# -eq 2 ] || { echo "Usage: uphost <old_ip> <new_ip>" >&2 ; return 1 ; }
    o="$1" ; t="$2" ;
    for f in ~/.ssh/config /etc/nftables.conf /etc/ufw/user.rules ; do
        sed "s/${o}/${t}/" "$f" | grep "${t}"
    done
}

suphost() {
    [ $# -eq 2 ] || { echo "Usage: uphost <old_ip> <new_ip>" >&2 ; return 1 ; }
    o="$1" ; t="$2" ;
    for f in ~/.ssh/config /etc/nftables.conf /etc/ufw/user.rules ; do
        sudo sed -i "s/${o}/${t}/" "$f" | grep "${t}"
    done
    upfw || return 1
    return 0
}

rxr() {
    dwmpid=$(pidof dwm) || return 1 ;
    ( xrdb -merge ~/.Xresources  && kill -HUP  "${dwmpid}" ; ) || return 1 ;
    return 0
}

ww() {
    ewww-browse "$@" >/dev/null 2>&1 || return 1
    return 0
}

cava_visualizer() {
    wininfo=$(xwininfo -root -tree | grep '("dwm" "dwm")')
    winid=$(echo "$wininfo" | awk '{print $1}')
    if ! pidof -xs cava 2>/dev/null 2>&1 ; then
        st -w "$winid" -t "cavaviz" -g 12x2+1510+1 -i -e cava || return 1
    else
        ps aux | grep -v 'grep' | grep -E "cavaviz" 2>/dev/null | awk '{print $2}' | xargs kill 2>/dev/null || return 1
    fi
    return 0
}

cava_send() {
    [ -f "/tmp/cava.winid" ] && cava=$(cat /tmp/cava.winid) || cava_visualizer
    [ -n "$cava" ] && xdotool key --window "$cava" "$@" || return 1
    return 0
}
cava_show() {
    ([ -f "/tmp/cava.winid" ] && cava=$(cat /tmp/cava.winid) ) || cava_visualizer
    ( [ ! -f "/tmp/cava.hidden" ] && xdo hide "$cava" && echo "$cava" >"/tmp/cava.hidden" ) || { xdo show "$cava" ; rm -f "/tmp/cava.hidden" ; }
    return 0
}

exifjpg_extract() {
    f="$1"
    exifjpg -FDtgu "$f" | jq -r 'to_entries[] | "\(.key)\t\(.value)"'
    printf 'Path\t%s\n' "$f"
}
exifjpg2tbl() { f="$1" ; [ -L "$f" ] && f=$(readlink -f "$f") || f=$(realpath "$f") ; exifjpg -S "\t" -Dtgu $f ; printf '\t%s\n' "$f" ; }
exifjpg2tbl_header() { f="$1" ; h=$(printf 'Date\tTitle\tDuration\tUri\tThumbnail\n') ; [ -f "$f" ] || echo "$h" > "$f" ; [ "$(head -n 1 "$f")" = "$h" ] || sed -i "1i ${h}" "$f" ; }

mkorglinks() {
    d="$1" ; t="$2" ; n="$3"
    find "$d" -type "$t" -iname "${n}*" | sort -t '/' -k 3 | while read -r l ; do
        f=$(realpath "$l") ; n=${f##*/} ; ln=${n%.*} ; printf '[[%s]]\n[[%s][%s]]\n' "$f" "$f" "$ln"
    done
}

for_dir_alphabet_mkorgln() {
   dir="$1" ; dn=$(basename "$(dirname "$dir")")
   printf "\n* %s\n\n" "$dn"
   for a in {a..z} ; do
       A=$(toupper "$a")
       printf '** %s\n' "$A"
       mkorglinks "$dir" l "$a"
   done
}

find_ytdirs_sort_prefix() {
    find "$HOME/Videos/yt" -maxdepth 1 -not -iname "meta*" -type d | sort -t '/' -k 3
}

#  find_ytdirs_sort_prefix | while read -r d ; do
#      printf '* %s\n\n' "$(basename "$(dirname "$d")")"
#      for_dir_alphabet_mkorglink "$d" l  >> "$HOME/Videos/yt/TOC.org"
#  done

#  git clone --bare https://bitbucket.org/cf.tty.gg/dotfiles.git $HOME/.dotfiles
#  dotgit {
#      [ -d "$HOME/.dotfiles" ] || mkdir -p ~/.dotfiles
#     /usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME $@
#  }
#  dotgit checkout
#  if [ $? = 0 ]; then
#    echo "Checked out config.";
#  else
#      echo "Backing up pre-existing dot files.";
#      config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | xargs -I{} mv {} ~/.dotfiles/{}
#  fi
#  dotgit checkout
#  dotgit status.showUntrackedFiles no
